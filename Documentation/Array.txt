10 Faces
20 eges
12 primary vertices
t = tesselation level (equals to the number of sides an edge is being divided into)


     0         0         0         0         0
     /\        /\        /\        /\        /\
    /  \      /  \      /  \      /  \      /  \
  e13   e1   e1   e4   e4   e7   e7  e10  e10  e13
  /      \  /      \  /      \  /      \  /      \
 /        \/        \/        \/        \/        \
t13  f9   t1   f1   t4   f3   t7   f5   t10  f7   t13      
 \        /\        /\        /\        /\        /\
  \      /  \      /  \      /  \      /  \      /  \
  e14  e16   e2  e17   e5  e18   e8  e19  e11  e20  e14
    \  /      \  /      \  /      \  /      \  /      \
     \/        \/        \/        \/        \/        \
     t14  f10  t2   f2   t5   f4   t8   f6   t11  f8   t14
      \        /\        /\        /\        /\        /
       \      /  \      /  \      /  \      /  \      /
       e15   e3   e3   e6   e6   e9   e9  e12  e12  e15
         \  /      \  /      \  /      \  /      \  /
          \/        \/        \/        \/        \/
         (t3)       t3       (t3)      (t3)      (t3)     
          t15                 t6        t9        t12

[0]	    	- Point 1; North Pole; lat(pi/2),long(0)

[1t]		- Point 2; Lat(pi/2 - acos(sqrt(5)/5)), Long(0)
[2t]		- point 3; Lat(-(pi/2 - acos(sqrt(5)/5))), Long((2*pi)/(5*2))

[3t]		- point 4; South Pole; Lat(-pi/2), Long(0)

[4t]		  - Point 5; Lat(pi/2 - acos(sqrt(5)/5)), Long((2*pi)/5)
[5t]        - Point 6; Lat(-(pi/2 - acos(sqrt(5)/5))), Long((3*2*pi/(5*2)))

[6t] = [3t] - point 4; South Pole; use pointer to [t3] or leave null

[7t]		  - Point 7; Lat(pi/2 - acos(sqrt(5)/5)), Long((2*2*pi)/5)
[8t]        - point 8; Lat(-(pi/2 - acos(sqrt(5)/5))), Long((5*2*pi/(5*2)))

[9t] = [3t] - point 4; South Pole; use pointer to [t3] or leave null

[10t]	  - Point 9; Lat(pi/2 - acos(sqrt(5)/5)), Long((3*2*pi)/5)
[11t]       - Point 10; Lat(-(pi/2 - acos(sqrt(5)/5))), Long((7*2*pi/(5*2)))

[12t] = [3t] - Point 4; South Pole; use pointer to [t3] or leave null

[13t]	  - Point 11; Lat(pi/2 - acos(sqrt(5)/5)), Long((4*2*pi)/5)
[14t]       - Point 12; Lat(-(pi/2 - acos(sqrt(5)/5))), Long((9*2*pi/(5*2)))

[15t] = [3t] - Point 4; South Pole; use pointer to [t3] or leave null

Edge Addressing:
e1 =  (0,   [   1,   1t-1], 1t)
e2 =  (1t,  [1t+1,   2t-1], 2t)
e3 =  (2t,  [2t+1,   3t-1], 3t)
e4 =  (0,   [3t+1,   4t-1], 4t)
e5 =  (4t,  [4t+1,   5t-1], 5t)
e6 =  (5t,  [5t+1,   6t-1], 3t)   // 6t is null
e7 =  (0,   [6t+1,   7t-1], 7t)
e8 =  (7t,  [7t+1,   8t-1], 8t)
e9 =  (8t,  [8t+1,   9t-1], 3t)   // 9t is null
e10 = (0,   [9t+1,  10t-1], 10t)
e11 = (10t, [10t+1, 11t-1], 11t)
e12 = (11t, [11t+1, 12t-1], 3t)   // 12t is null
e13 = (0,   [12t+1, 13t-1], 13t)
e14 = (13t, [13t+1, 14t-1], 14t)
e15 = (14t, [14t+1, 15t-1], 3t)   // 15t is null
e16 = (1t,  [15t+1, 16t-1], 14t)  // 16t is null
e17 = (4t,  [16t+1, 17t-1], 2t)   // 17t is null
e18 = (7t,  [17t+1, 18t-1], 5t)   // 18t is null
e19 = (10t, [18t+1, 19t-1], 8t)   // 19t is null
e20 = (13t, [19t+1, 20t-1], 11t)  // 20t starts the addressing of the face vertices.

Face Vertex Addressing:
f0 = [            20t,   (t-1)^2 + 20t - 1 ] ; 20t, t^2+18t
f1 = [  (t-1)^2 + 20t,  2(t-1)^2 + 20t - 1 ] ; t^2+18t+1, 
f2 = [ 2(t-1)^2 + 20t,  3(t-1)^2 + 20t - 1 ] ; 2t^2+16t+2, 
f3 = [ 3(t-1)^2 + 20t,  4(t-1)^2 + 20t - 1 ] ; 3t^2+14t+3,
f4 = [ 4(t-1)^2 + 20t,  5(t-1)^2 + 20t - 1 ] ; 4t^2+12t+4,
f5 = [ 5(t-1)^2 + 20t,  6(t-1)^2 + 20t - 1 ] ; 5t^2+10t+5,
f6 = [ 6(t-1)^2 + 20t,  7(t-1)^2 + 20t - 1 ] ; 6t^2+8t+6,
f7 = [ 7(t-1)^2 + 20t,  8(t-1)^2 + 20t - 1 ] ; 7t^2+6t+7,
f8 = [ 8(t-1)^2 + 20t,  9(t-1)^2 + 20t - 1 ] ; 8t^2+4t+8,
f9 = [ 9(t-1)^2 + 20t, 10(t-1)^2 + 20t - 1 ] ; 9t^2+2t+9,

number of vertices inside of a face that DON'T make up an edge; 
(t-1)^2 where t = tesselation or the number of edges a primary edge is divided into.

10 faces so 
(t-1)^2 * 10 
The first row & column is already 0 so it doesn't get counted, minus 1 to not count the opposite row & column since we're determining the number of verticies in a face, not counting the outside edges. The outside edges have already been calculated.

Size of the vertex array:
10 faces + 20 edges + 12 points + 8 null points
(t-1)^2 * 10 + (t-1) * 20 + 12 + 8 (THIS IS A QUADRATIC EQUATION!)
Simplifies to 10 * t^2 + 10 (fuck yeah!) 
Note: address [0] counts as 1 which is why the last address used on f10 is 1 less than the calculation for the size of the vertex array.
10(t-1)^2 + 20t = 10*t^2 + 10

Size of the face array:
10 faces
t = # of subdivded edges along a primary edge.
so 10 * (t^2) = the number of subdivided faces.

Addressing of faces would then be done when applying the haversign formulas.
1. Using the primary 12 points, subdivide the edges using the haversign formula.
2. Since subdividing the face uses the edge vertices, I can address the face vertices by Face, Column, & Row.
     a. Since I know the address of each vertex, they can be applied to each face mathmatically.
     b. Face 0 ( contains r0c0, r0c1, r1c0, & r1c1 ) and so on.
     c. Should I make another array that stores the addresses for each vertex? Should it be a structured value in the vertex itself?
3. using the points of the edges of the next row, subdivide the next row. (or column, pick one)
4. I guess it doesn't matter when I allocate the vertices to the faces, either as I create the vertices or once the entire thing is done. I need to use the same methodology either way.
     a. Faces per row/column are a factor of (t). Use that.
5. We break down the subdivision of each face per each face. This could allow us to generate a single tile of terrain for testing if we wish.

1. Subdivide e1, [0] & [1t]
  - store in [1, 1t-1]
2. Subdivide e2, [1t] & [2t]
  - store in [2t+1, 3t-1]
  - store in [1t+1, 2t-1]
3. Subdivide e3, [2t] & [3t]
4. Subdivide e4, [0] & [4t]
  - store in [3t+1, 4t-1]
5. subdivide e5, [4t] & [5t]
  - store in [4t+1, 5t-1]
6. subdivide e6, [5t] & [3t]
  - store in [5t+1, 6t-1]
7. subdivide e7, [0] & [7t]
  - store in [6t+1, 7t-1]
8. subdivde e8, [7t] & [8t]
  - store in [7t+1, 8t-1]
9. subdivide e9, [8t] & [3t]
  - store in [8t+1, 9t-1]
10. subdivide e10, [0] & [10t]
  - store in [9t+1, 10t-1]
11. subdivide e11, [10t] & [11t]
  - store in [10t+1, 11t-1]
12. subdivide e12, [11t] & [3t]
  - store in [11t+1, 12t-1]
13. subdivide e13, [0] & [13t]
  - store in [12t+1, 13t-1]
14. subdivide e14, [13t] & [14t]
  - store in [13t+1, 14t-1]
15. subdivide e15, [14t] & [3t]
  - store in [14t+1, 15t-1]

16. subdivide e16, [1t] & [14t]
  - store in [15t+1, 16t-1]
17. subdivide e17, [4t] & [2t]
  - store in [16t+1, 17t-1]
18. subdivide e18, [7t] & [5t]
  - store in [17t+1, 18t-1]
19. subdivide e19, [10t] & [8t]
  - store in [18t+1, 19t-1]
20. subdivide e20, [13t] & [11t]
  - store in [19t+1, 20t-1]

l0 - primary edge
l1 - [20t,20t+t-2], [20t, 21t-2]
l2 - [20t+t-1, 20t+2t-1-2]; [21t-1, 22t-3]
l3 - [22t-2, 22t+t-2-2]; [22t-2, 23t-4]
ln - [20t+t(n-1)-(n-1), (20t+tn-(n+1)]

// Faces
// Face 0
// The first line is a primary line and thus is already subdivided.
// Face loops to be tracked.
21. subdivide 2nd line of F0
  - Using e1 & e17 as start and end points with the Northern-most point and the Eastern-most point to sub-divide the North-Eastern line and working the lines in order towards the South-Western line. Each line is worked from North to East.
  - subdivide [x], [y]
     - loop start: x=1, y=16t+1; this is the array address for the start and end points.
     - increment by +1 each loop until x = t1 (do not run on x = t1) // verify
     - each loop represents an entire line having been sub-divided.
- store in [(c+b)t+a, (c+1)t-1]
  - the first internal point of each line will have an array address that is a factor of "t-1"-1 (offset of 1 due to start of 0.)
  - loop start: a=0, b=0, c=20 
    - "a" modifies the array address for each point along the line being subdivided.
    - "b" modifies the array address for the first point on each line. When this increments +1, "a" needs to reset to 0.
    - "c" is the global variable and will be used to track array usage between faces.
  - increment a by +1 each loop until a=t but does not run if a=t as that would be a point along a primary edge.
    - for Haversign purposes, each of these lines are spherically parallel to the icosahedron central angle, acos(sqrt(5)/5). Need to verify. This might simplify the math.
  - if a=t, then ++b and a=0
  - if b=t, then end loop and set c=  // verify math for c
  - start next face.
